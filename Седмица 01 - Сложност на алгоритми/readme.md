# Седмица 01 - Сложност на алгоритми

## Дефиниция на алгоритъм
Често използвана дефиниция за алгоритъм е "добре дефиниран набор от инструкции за извършване на дадено пресмятане". Тази дефиниция обаче не е математически формална. Всъщност няма общоприета формална дефиниция на понятието алгоритъм. Когато говорим за алгоритми, това е най-вече в контекста на изчислимите функции - това е клас от функции, които могат да се предтавят чрез машини на Тюринг, изрази в ламбда смятането и други модели за изчисление, включително и компютърни програми. Всяка изчислима функция има много възможни програми (независимо от модела), които я пресмятат. Не можем обаче да отъждествим програма и алгоритъм, понеже програмата е конкретна реализация, докато терминът алгоритъм по-скоро обхваща идейната последователност от инструкции. Нещо повече, две програми могат да реализират един и същ алгоритъм по различен начин. Липсата на формалност в понятието алгоритъм, позволява множество интерпретации, като за част от тях може да прочетете [тук](https://en.wikipedia.org/wiki/Algorithm_characterizations). За простота, в този курс ние ще използваме дадената по-горе неформална дефиниция, понеже за нашите цели тя е достатъчно описателна.

## Сравняване на алгоритми
Както стана дума, няколко различни програми могат да решават един и същи проблем, реализирайки различни алгоритми. Естествено, възниква въпросът кой от всички алгоритми за дадена задача е най-добрият? За да отговорим на този въпрос, трябва да имаме мярка, спрямо която да сравняваме алгоритми. Тази мярка обикновено наричаме сложност на алгоритъм, като има 2 вида сложност:
- сложност по време (time complexity)
- сложност по памет (space complexity)

На практика сложността на алгоритъма определя ресурсите, необходими за решаването на изчислителната задача. Как обаче сравняваме 2 алгоритъма спрямо тяхната сложност? Ако броим направените процесорни инструкции и използвани байтове, то това ще зависи от архитектурата на процесора. За улеснение можем да предположим, че всяка инструкция е атомарна, т.е. изпълнява се за 1 такт, и работим с единици памет вместо конкретно с байтове, но тогава тяхната бройка ще зависи от размера на входа на алгоритъма. Решението е да използваме функция на броя операции и променливи, която е независима от размера на входа. Сега обаче възниква нов проблем - как да сравняваме функции. Всъщност няма да сравняваме техните стойности, а ще сравняваме тяхното нарастване при нарастването на големината на входа. За целта трябва да можем да категоризираме функции в класове спрямо поведението им при нарастващи стойности. Това се случва като използваме т.нар. О-нотация. При нея дефинираме следните класове от функции:

- $` O(g) = {f \mid \exists c \gt 0, \exists n_0 \in \mathbb{N}, \forall n \ge n_0: 0 \le f(n) \le c \cdot g(n) } `$

- $` \Omega(g) = {f \mid \exists c \gt 0, \exists n_0 \in \mathbb{N}, \forall n \ge n_0: 0 \le c \cdot g(n) \le f(n) } `$

- $` \Theta(g) = {f \mid \exists c_1 \gt 0, c_2 \gt 0, \exists n_0 \in \mathbb{N}, \forall n \ge n_0: 0 \le c_1 \cdot g(n) \le f(n) \le c_2 \cdot g(n) } `$

Така, ако например алгоритъм има сложност по време f(n) = 3n<sup>2</sup> + 10n, където n е размерът на входа, то $ f \in O(n^3), f \in O(n^{10}), f \in O(n^2), f \in \Omega(n), f \in \Omega(1), f \in \Theta(n^2) $

Винаги, когато пресмятаме сложността на даден алгоритъм, е важно да вземем в предвид следната графика:

<div style="text-align:center">
  <img src="./complexity_graph.png" alt="graph" />
</div>

Когато определяме каква е сложността на алгоритъм трябва да вземем в предвид това за кои случаи се отнася - например може програмата да не се очаква да работи с големи по размер входове и да се интересуваме от сложността само при определ вид входове. Това налага допълнителна класификация на видовете сложности:
- сложност в лошия случай - разглеждаме сложността на алгоритъма при най-неблагоприятните входове, т.е. тези, при които алгоритъма извършва най-голям брой операции / използва най-голям размер памет
- сложност в добрия случай - разглеждаме сложността на алгоритъма при най-благоприятните входове, т.е. тези, при които алгоритъма извършва най-малък брой операции / използва най-малък размер памет
- сложност в средния случай - разглеждаме сложността на алгоритъма като приемем, че всеки възможен вход е равновероятен, т.е. взимаме в предвид "средното аритметично" на броя операции / размера памет
- амортизирана сложност - ако алгоритъмът ще се изпълни многократно в рамките на една програма, разглеждаме сложността на алгоритъма като вземем в предвид средния брой операции / размер памет

Обикновено разглеждаме сложността на алгоритмите в лошия случай. Ако всички входове са равновероятни (или близки до равновероятни), то разглеждаме алгоритъма в средния случай. Ако алгоритъмът ще се изпълнява много пъти в рамките на програмата, е по-коректно да разгледаме амортизираната му сложност. Сложността в добрия случай се разглежда рядко, най-често когато имаме частни случаи или е много по-вероятно входът да е благоприятен.

## Задача 01 - Определяне на сложности
Определете сложността по време на следните алгоритми:
- филтриране на елементите в масив, отговарящи на даден предикат
- обръщане на реда на знаците в символен низ
- премахване на елемент от масив
- вмъкване на елемент в масив след елемент отговарящ на предикат
- намиране на броя на цифрите на число
- добавяне на елемент в края на масив - сравнете сложността в лошия случай и амортизираната сложност

Определете сложността на следния алгоритъм:
```c++
int sum = 0;
for (int i = 0; i < 100; ++i) {
  sum += i;
}
std::cout << sum << '\n';
```

## Задача 02 - Бавни сортировки
Реализирайте следните алгоритми за сортиране и определете сложността им по време и памет:
- сортиране по метода на пряката селекция (selection sort)
- сортиране по метода на мехурчето (bubble sort)
- сортиране чрез вмъкване (insertion sort)

## Задача 03 - Бързи сортировки
Реализирайте следните алгоритми за сортиране и определете сложността им по време и памет:
- сортиране чрез сливане (merge sort)
- бързо сортиране (quick sort)

## Задача 04 - Двоично търсене
Реализирайте алгоритъма за двоично търсене в сортиран масив. Вярното решение трябва да е със сложност по време от порядък O(log n) (При логаритмичните функции основата често се изпуска).

## Задача 05 - Бързо степенуване
Реализирайте алгоритъм за степенува, имащ сложност по време от порядък O(log n).
